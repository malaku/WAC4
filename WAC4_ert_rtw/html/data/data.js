var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"MalaksModelSub/WAC4","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\WAC4_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'WAC4'.\r\n *\r\n * Model version                  : 1.63\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Thu Nov  9 17:46:37 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"WAC4.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"limits.h\"\r\n#include \"linuxinitialize.h\"\r\n#define UNUSED(x)                      x = x\r\n#define NAMELEN                        16\r\n\r\n/* Function prototype declaration*/\r\nvoid exitFcn(int sig);\r\nvoid *terminateTask(void *arg);\r\nvoid *baseRateTask(void *arg);\r\nvoid *subrateTask(void *arg);\r\nvolatile boolean_T stopRequested = false;\r\nvolatile boolean_T runModel = true;\r\nsem_t stopSem;\r\nsem_t baserateTaskSem;\r\npthread_t schedulerThread;\r\npthread_t baseRateThread;\r\nvoid *threadJoinStatus;\r\nint terminatingmodel = 0;\r\nvoid *baseRateTask(void *arg)\r\n{\r\n  runModel = (rtmGetErrorStatus(rtM) == (NULL));\r\n  while (runModel) {\r\n    sem_wait(&baserateTaskSem);\r\n    WAC4_step();\r\n\r\n    /* Get model outputs here */\r\n    stopRequested = !((rtmGetErrorStatus(rtM) == (NULL)));\r\n    runModel = !stopRequested;\r\n  }\r\n\r\n  runModel = 0;\r\n  terminateTask(arg);\r\n  pthread_exit((void *)0);\r\n  return NULL;\r\n}\r\n\r\nvoid exitFcn(int sig)\r\n{\r\n  UNUSED(sig);\r\n  rtmSetErrorStatus(rtM, \"stopping the model\");\r\n}\r\n\r\nvoid *terminateTask(void *arg)\r\n{\r\n  UNUSED(arg);\r\n  terminatingmodel = 1;\r\n\r\n  {\r\n    runModel = 0;\r\n  }\r\n\r\n  sem_post(&stopSem);\r\n  return NULL;\r\n}\r\n\r\nint main(int argc, char **argv)\r\n{\r\n  rtmSetErrorStatus(rtM, 0);\r\n\r\n  /* Initialize model */\r\n  WAC4_initialize();\r\n\r\n  /* Call RTOS Initialization function */\r\n  myRTOSInit(0.01, 0);\r\n\r\n  /* Wait for stop semaphore */\r\n  sem_wait(&stopSem);\r\n\r\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\r\n\r\n  {\r\n    int i;\r\n    for (i=0; i < MW_NUMBER_TIMER_DRIVEN_TASKS; i++) {\r\n      CHECK_STATUS(sem_destroy(&timerTaskSem[i]), 0, \"sem_destroy\");\r\n    }\r\n  }\r\n\r\n#endif\r\n\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"WAC4.c","type":"source","group":"model","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\WAC4_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: WAC4.c\r\n *\r\n * Code generated for Simulink model 'WAC4'.\r\n *\r\n * Model version                  : 1.63\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Thu Nov  9 17:46:37 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"WAC4.h\"\r\n#include \"rtwtypes.h\"\r\n#include <math.h>\r\n\r\n/* Block signals and states (default storage) */\r\nDW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY rtY;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL rtM_;\r\nRT_MODEL *const rtM = &rtM_;\r\nstatic void MATLABFunction(real_T rtu_delta_f, real_T rtu_vx, real_T rtu_l1,\r\n  real_T rtu_l2, real_T rtu_L, real_T rtu_m, real_T rtu_cs3, real_T rtu_cs2,\r\n  real_T *rty_delta_r);\r\n\r\n/*\r\n * Output and update for atomic system:\r\n *    '<S2>/MATLAB Function'\r\n *    '<S3>/MATLAB Function'\r\n */\r\nstatic void MATLABFunction(real_T rtu_delta_f, real_T rtu_vx, real_T rtu_l1,\r\n  real_T rtu_l2, real_T rtu_L, real_T rtu_m, real_T rtu_cs3, real_T rtu_cs2,\r\n  real_T *rty_delta_r)\r\n{\r\n  real_T tmp;\r\n  tmp = rtu_vx * rtu_vx;\r\n  *rty_delta_r = (rtu_m * rtu_l1 / (rtu_cs3 * rtu_L) * tmp + -rtu_l2) / (rtu_m *\r\n    rtu_l2 / (rtu_cs2 * rtu_L) * tmp + rtu_l1) * rtu_delta_f;\r\n}\r\n\r\n/* Model step function */\r\nvoid WAC4_step(void)\r\n{\r\n  real_T desiredfw2_tmp;\r\n  real_T rtb_Gain;\r\n\r\n  /* MATLAB Function: '<S7>/MATLAB Function4' incorporates:\r\n   *  UnitDelay: '<S7>/Unit Delay'\r\n   */\r\n  rtb_Gain = sin(rtDW.UnitDelay_DSTATE);\r\n\r\n  /* Outport: '<Root>/desired fw1' incorporates:\r\n   *  Constant: '<S7>/Constant4'\r\n   *  Constant: '<S7>/Constant5'\r\n   *  MATLAB Function: '<S7>/MATLAB Function4'\r\n   *  UnitDelay: '<S7>/Unit Delay'\r\n   */\r\n  rtY.desiredfw1 = atan(2.0 * rtP.L * rtb_Gain / (2.0 * rtP.L * cos\r\n    (rtDW.UnitDelay_DSTATE) - rtP.Bf * rtb_Gain));\r\n\r\n  /* Gain: '<S1>/Gain' incorporates:\r\n   *  Inport: '<Root>/In1'\r\n   */\r\n  rtb_Gain = rtP.Gain_Gain * rtU.Steeringwheelangle;\r\n\r\n  /* MATLAB Function: '<S6>/MATLAB Function5' */\r\n  desiredfw2_tmp = sin(rtb_Gain);\r\n\r\n  /* Outport: '<Root>/desired fw2' incorporates:\r\n   *  Constant: '<S6>/Constant6'\r\n   *  Constant: '<S6>/Constant7'\r\n   *  MATLAB Function: '<S6>/MATLAB Function5'\r\n   */\r\n  rtY.desiredfw2 = atan(2.0 * rtP.L * desiredfw2_tmp / (2.0 * rtP.L * cos\r\n    (rtb_Gain) + rtP.Bf * desiredfw2_tmp));\r\n\r\n  /* MATLAB Function: '<S3>/MATLAB Function' incorporates:\r\n   *  Constant: '<S3>/Constant'\r\n   *  Constant: '<S3>/Constant1'\r\n   *  Constant: '<S3>/Constant2'\r\n   *  Constant: '<S3>/Constant3'\r\n   *  Constant: '<S3>/Constant4'\r\n   *  Constant: '<S3>/Constant5'\r\n   *  Gain: '<S1>/Gain2'\r\n   *  Inport: '<Root>/In1'\r\n   *  Inport: '<Root>/vx'\r\n   */\r\n  MATLABFunction(rtP.Gain2_Gain * rtU.Steeringwheelangle, rtU.ActualVelocity,\r\n                 rtP.l1, rtP.l2, rtP.L, rtP.m, rtP.cs3, rtP.cs2, &rtb_Gain);\r\n\r\n  /* MATLAB Function: '<S5>/MATLAB Function' */\r\n  desiredfw2_tmp = sin(rtb_Gain);\r\n\r\n  /* Outport: '<Root>/desired rw1' incorporates:\r\n   *  Constant: '<S5>/Constant'\r\n   *  Constant: '<S5>/Constant1'\r\n   *  MATLAB Function: '<S5>/MATLAB Function'\r\n   */\r\n  rtY.desiredrw1 = atan(2.0 * rtP.L * desiredfw2_tmp / (2.0 * rtP.L * cos\r\n    (rtb_Gain) - rtP.Bf * desiredfw2_tmp));\r\n\r\n  /* MATLAB Function: '<S2>/MATLAB Function' incorporates:\r\n   *  Constant: '<S2>/Constant'\r\n   *  Constant: '<S2>/Constant1'\r\n   *  Constant: '<S2>/Constant2'\r\n   *  Constant: '<S2>/Constant3'\r\n   *  Constant: '<S2>/Constant4'\r\n   *  Constant: '<S2>/Constant5'\r\n   *  Gain: '<S1>/Gain1'\r\n   *  Inport: '<Root>/In1'\r\n   *  Inport: '<Root>/vx'\r\n   */\r\n  MATLABFunction(rtP.Gain1_Gain * rtU.Steeringwheelangle, rtU.ActualVelocity,\r\n                 rtP.l1, rtP.l2, rtP.L, rtP.m, rtP.cs3, rtP.cs2, &rtb_Gain);\r\n\r\n  /* MATLAB Function: '<S4>/MATLAB Function3' */\r\n  desiredfw2_tmp = sin(rtb_Gain);\r\n\r\n  /* Outport: '<Root>/desired rw2' incorporates:\r\n   *  Constant: '<S4>/Constant2'\r\n   *  Constant: '<S4>/Constant3'\r\n   *  MATLAB Function: '<S4>/MATLAB Function3'\r\n   */\r\n  rtY.desiredrw2 = atan(2.0 * rtP.L * desiredfw2_tmp / (2.0 * rtP.L * cos\r\n    (rtb_Gain) + rtP.Bf * desiredfw2_tmp));\r\n\r\n  /* Update for UnitDelay: '<S7>/Unit Delay' incorporates:\r\n   *  Gain: '<S1>/Gain3'\r\n   *  Inport: '<Root>/In1'\r\n   */\r\n  rtDW.UnitDelay_DSTATE = rtP.Gain3_Gain * rtU.Steeringwheelangle;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid WAC4_initialize(void)\r\n{\r\n  /* InitializeConditions for UnitDelay: '<S7>/Unit Delay' */\r\n  rtDW.UnitDelay_DSTATE = rtP.UnitDelay_InitialCondition;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"WAC4.h","type":"header","group":"model","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\WAC4_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: WAC4.h\r\n *\r\n * Code generated for Simulink model 'WAC4'.\r\n *\r\n * Model version                  : 1.63\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Thu Nov  9 17:46:37 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_WAC4_h_\r\n#define RTW_HEADER_WAC4_h_\r\n#ifndef WAC4_COMMON_INCLUDES_\r\n#define WAC4_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#endif                                 /* WAC4_COMMON_INCLUDES_ */\r\n\r\n#include <stddef.h>\r\n\r\n/* Model Code Variants */\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#define WAC4_M                         (rtM)\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM RT_MODEL;\r\n\r\n/* Block signals and states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T UnitDelay_DSTATE;             /* '<S7>/Unit Delay' */\r\n} DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real_T Steeringwheelangle;           /* '<Root>/In1' */\r\n  real_T ActualVelocity;               /* '<Root>/vx' */\r\n} ExtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T desiredfw1;                   /* '<Root>/desired fw1' */\r\n  real_T desiredfw2;                   /* '<Root>/desired fw2' */\r\n  real_T desiredrw1;                   /* '<Root>/desired rw1' */\r\n  real_T desiredrw2;                   /* '<Root>/desired rw2' */\r\n} ExtY;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_ {\r\n  real_T Bf;                           /* Variable: Bf\r\n                                        * Referenced by:\r\n                                        *   '<S4>/Constant2'\r\n                                        *   '<S5>/Constant'\r\n                                        *   '<S6>/Constant6'\r\n                                        *   '<S7>/Constant4'\r\n                                        */\r\n  real_T L;                            /* Variable: L\r\n                                        * Referenced by:\r\n                                        *   '<S2>/Constant2'\r\n                                        *   '<S3>/Constant2'\r\n                                        *   '<S4>/Constant3'\r\n                                        *   '<S5>/Constant1'\r\n                                        *   '<S6>/Constant7'\r\n                                        *   '<S7>/Constant5'\r\n                                        */\r\n  real_T cs2;                          /* Variable: cs2\r\n                                        * Referenced by:\r\n                                        *   '<S2>/Constant5'\r\n                                        *   '<S3>/Constant5'\r\n                                        */\r\n  real_T cs3;                          /* Variable: cs3\r\n                                        * Referenced by:\r\n                                        *   '<S2>/Constant4'\r\n                                        *   '<S3>/Constant4'\r\n                                        */\r\n  real_T l1;                           /* Variable: l1\r\n                                        * Referenced by:\r\n                                        *   '<S2>/Constant'\r\n                                        *   '<S3>/Constant'\r\n                                        */\r\n  real_T l2;                           /* Variable: l2\r\n                                        * Referenced by:\r\n                                        *   '<S2>/Constant1'\r\n                                        *   '<S3>/Constant1'\r\n                                        */\r\n  real_T m;                            /* Variable: m\r\n                                        * Referenced by:\r\n                                        *   '<S2>/Constant3'\r\n                                        *   '<S3>/Constant3'\r\n                                        */\r\n  real_T UnitDelay_InitialCondition;   /* Expression: 0\r\n                                        * Referenced by: '<S7>/Unit Delay'\r\n                                        */\r\n  real_T Gain_Gain;                    /* Expression: 1/16\r\n                                        * Referenced by: '<S1>/Gain'\r\n                                        */\r\n  real_T Gain2_Gain;                   /* Expression: 1/16\r\n                                        * Referenced by: '<S1>/Gain2'\r\n                                        */\r\n  real_T Gain1_Gain;                   /* Expression: 1/16\r\n                                        * Referenced by: '<S1>/Gain1'\r\n                                        */\r\n  real_T Gain3_Gain;                   /* Expression: 1/16\r\n                                        * Referenced by: '<S1>/Gain3'\r\n                                        */\r\n};\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_ P;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P rtP;\r\n\r\n/* Block signals and states (default storage) */\r\nextern DW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY rtY;\r\n\r\n/* Model entry point functions */\r\nextern void WAC4_initialize(void);\r\nextern void WAC4_step(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL *const rtM;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Note that this particular code originates from a subsystem build,\r\n * and has its own system numbers different from the parent model.\r\n * Refer to the system hierarchy for this subsystem below, and use the\r\n * MATLAB hilite_system command to trace the generated code back\r\n * to the parent model.  For example,\r\n *\r\n * hilite_system('MalaksModelSub/WAC4')    - opens subsystem MalaksModelSub/WAC4\r\n * hilite_system('MalaksModelSub/WAC4/Kp') - opens and selects block Kp\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'MalaksModelSub'\r\n * '<S1>'   : 'MalaksModelSub/WAC4'\r\n * '<S2>'   : 'MalaksModelSub/WAC4/RWS'\r\n * '<S3>'   : 'MalaksModelSub/WAC4/RWS1'\r\n * '<S4>'   : 'MalaksModelSub/WAC4/Subsystem'\r\n * '<S5>'   : 'MalaksModelSub/WAC4/Subsystem1'\r\n * '<S6>'   : 'MalaksModelSub/WAC4/Subsystem2'\r\n * '<S7>'   : 'MalaksModelSub/WAC4/Subsystem3'\r\n * '<S8>'   : 'MalaksModelSub/WAC4/RWS/MATLAB Function'\r\n * '<S9>'   : 'MalaksModelSub/WAC4/RWS1/MATLAB Function'\r\n * '<S10>'  : 'MalaksModelSub/WAC4/Subsystem/MATLAB Function3'\r\n * '<S11>'  : 'MalaksModelSub/WAC4/Subsystem1/MATLAB Function'\r\n * '<S12>'  : 'MalaksModelSub/WAC4/Subsystem2/MATLAB Function5'\r\n * '<S13>'  : 'MalaksModelSub/WAC4/Subsystem3/MATLAB Function4'\r\n */\r\n#endif                                 /* RTW_HEADER_WAC4_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"WAC4_data.c","type":"source","group":"data","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\WAC4_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: WAC4_data.c\r\n *\r\n * Code generated for Simulink model 'WAC4'.\r\n *\r\n * Model version                  : 1.63\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Thu Nov  9 17:46:37 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"WAC4.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP rtP = {\r\n  /* Variable: Bf\r\n   * Referenced by:\r\n   *   '<S4>/Constant2'\r\n   *   '<S5>/Constant'\r\n   *   '<S6>/Constant6'\r\n   *   '<S7>/Constant4'\r\n   */\r\n  1.552,\r\n\r\n  /* Variable: L\r\n   * Referenced by:\r\n   *   '<S2>/Constant2'\r\n   *   '<S3>/Constant2'\r\n   *   '<S4>/Constant3'\r\n   *   '<S5>/Constant1'\r\n   *   '<S6>/Constant7'\r\n   *   '<S7>/Constant5'\r\n   */\r\n  2.72,\r\n\r\n  /* Variable: cs2\r\n   * Referenced by:\r\n   *   '<S2>/Constant5'\r\n   *   '<S3>/Constant5'\r\n   */\r\n  4500.0,\r\n\r\n  /* Variable: cs3\r\n   * Referenced by:\r\n   *   '<S2>/Constant4'\r\n   *   '<S3>/Constant4'\r\n   */\r\n  11207.0,\r\n\r\n  /* Variable: l1\r\n   * Referenced by:\r\n   *   '<S2>/Constant'\r\n   *   '<S3>/Constant'\r\n   */\r\n  1.12695753,\r\n\r\n  /* Variable: l2\r\n   * Referenced by:\r\n   *   '<S2>/Constant1'\r\n   *   '<S3>/Constant1'\r\n   */\r\n  1.59304247,\r\n\r\n  /* Variable: m\r\n   * Referenced by:\r\n   *   '<S2>/Constant3'\r\n   *   '<S3>/Constant3'\r\n   */\r\n  1609.23,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S7>/Unit Delay'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1/16\r\n   * Referenced by: '<S1>/Gain'\r\n   */\r\n  0.0625,\r\n\r\n  /* Expression: 1/16\r\n   * Referenced by: '<S1>/Gain2'\r\n   */\r\n  0.0625,\r\n\r\n  /* Expression: 1/16\r\n   * Referenced by: '<S1>/Gain1'\r\n   */\r\n  0.0625,\r\n\r\n  /* Expression: 1/16\r\n   * Referenced by: '<S1>/Gain3'\r\n   */\r\n  0.0625\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\WAC4_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'WAC4'.\r\n *\r\n * Model version                  : 1.63\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Thu Nov  9 17:46:37 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: MATLAB Host\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  64\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\WAC4_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'WAC4'.\r\n *\r\n * Model version                  : 1.63\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Thu Nov  9 17:46:37 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"WAC4.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"MW_custom_RTOS_header.h","type":"header","group":"other","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\WAC4_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_CUSTOM_RTOS_HEADER_H_\r\n#define _MW_CUSTOM_RTOS_HEADER_H_\r\n#define MW_BASERATE_PRIORITY           40\r\n#define MW_BASERATE_PERIOD             0.01\r\n#define MW_NUMBER_SUBRATES             0\r\n#define MW_NUMBER_APERIODIC_TASKS      0\r\n#define MW_IS_CONCURRENT               0\r\n#define MW_NUMBER_TIMER_DRIVEN_TASKS   0\r\n\r\nextern void exitFcn(int sig);\r\nextern void *terminateTask(void *arg);\r\nextern void *baseRateTask(void *arg);\r\nextern void *subrateTask(void *arg);\r\nextern pthread_t schedulerThread;\r\nextern pthread_t baseRateThread;\r\nextern pthread_t subRateThread[];\r\nextern sem_t stopSem;\r\nextern sem_t baserateTaskSem;\r\nextern sem_t subrateTaskSem[];\r\nextern int taskId[];\r\nextern int subratePriority[];\r\n\r\n#endif\r\n\r\n#define MW_MAX_TASKNAME                16\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\WAC4_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE BeagleBone Black\n#define MW_CONNECTIONINFO_TCPIP_IPADDRESS codertarget.beaglebone.internal.getBoardParam('Hostname')\n#define MW_CONNECTIONINFO_TCPIP_PORT 17725\n#define MW_CONNECTIONINFO_TCPIP_VERBOSE 0\n#define MW_CONNECTIONINFO_TCPIP_RUNINBACKGROUND 1\n#define MW_EXTMODE_CONFIGURATION TCP/IP\n#define MW_RTOS Linux\n#define MW_RTOSBASERATETASKPRIORITY 40\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_BOARDPARAMETERS_DEVICEADDRESS 192.168.7.2\n#define MW_BOARDPARAMETERS_USERNAME debian\n#define MW_BOARDPARAMETERS_PASSWORD temppwd\n#define MW_RUNTIME_BUILDACTION 2\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 1000\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"linuxinitialize.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2022a\\toolbox\\target\\codertarget\\rtos\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n\n/* ---------------------------- */\n/* RTOS-specific headers        */\n/* Note: must be included first */\n/* ---------------------------- */\n#include \"linuxinitialize.h\"\n#include \"rtwtypes.h\"\n/* ---------------------------- */\n/* Required Coder Target header */\n/* ---------------------------- */\n#include \"MW_custom_RTOS_header.h\"\n\n#if defined(MW_SOC_ENABLED) && defined(MW_KERNEL_PROFILING_ON)   \n#include \"kernelprofiler-tp.h\"\n#endif\n\n#if (MW_NUM_APERIODIC_PROXY_TASKS > 0)\n#include \"mw_cpuloadgenerator.h\"\n#endif\n\n#define NAMELEN 16\n\ntypedef struct {\n    void* (*pAsyncTasks)(void* arg);\n    char taskName[NAMELEN];\n    int priority;\n    int policy;\n    int coreSelection;\n    int coreNum;\n} MW_AsyncTaskCodeGenInfo_Type;\n\n#if (defined(MW_TSKMGR_EVENT_DRIVEN_TASKS) && (MW_TSKMGR_EVENT_DRIVEN_TASKS > 0))\nstatic MW_AsyncTaskCodeGenInfo_Type asyncTaskCodeGenInfo[MW_TSKMGR_EVENT_DRIVEN_TASKS];\n\nvoid mw_setAsyncTaskCodeGenInfo(void * (*taskHandler)(void *), \n        const char* taskName, int priority, int policy, \n        int coreSelection, int coreNum, int idx)\n{\n    asyncTaskCodeGenInfo[idx].pAsyncTasks = taskHandler;\n    snprintf(asyncTaskCodeGenInfo[idx].taskName, NAMELEN, \"%s\", taskName);\n    asyncTaskCodeGenInfo[idx].priority = priority;\n    asyncTaskCodeGenInfo[idx].policy = policy;\n    asyncTaskCodeGenInfo[idx].coreSelection = coreSelection;\n    asyncTaskCodeGenInfo[idx].coreNum = coreNum;\n}\n#endif\nextern volatile boolean_T runModel;\n/* ---------------------------- */\n/* RTOS-specific declarations   */\n/* ---------------------------- */\ntypedef struct {\n    double period;\n} baseRateInfo_t;\n\npthread_t baseTimerThread;\n#if (MW_NUM_APERIODIC_PROXY_TASKS > 0)   \npthread_t proxyTaskEventSrcThread;\n#endif\n\npthread_attr_t attr;\nbaseRateInfo_t info;\nstruct sched_param sp;\n\n/* MW_NUM_SUBRATES is set to 0 if we are in single-tasking mode or number of subrates are 0 */\n#define MW_SP_SCHED_FIFO ((MW_NUMBER_SUBRATES > 0) || !defined(MW_SCHED_OTHER))\n#ifdef MW_RTOS_DEBUG\n    #define MW_DEBUG_LOG(str)  printf(str); fflush(stdout)\n#else\n    #define MW_DEBUG_LOG(str)\n#endif\n\n#ifdef MW_HAS_COMM_SERVICE\n    extern int makeCSTaskIdle();\n#endif\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\n    sem_t timerTaskSem[MW_NUMBER_TIMER_DRIVEN_TASKS];\n    int timer_fd[MW_NUMBER_TIMER_DRIVEN_TASKS];\n    double timer_period[MW_NUMBER_TIMER_DRIVEN_TASKS];\n#endif\n    \nint mw_CreateArmedTimer(double period)\n{\n    int status;\n    int fd;\n    struct itimerspec its;\n\n    /* Create the timer */\n    fd = timerfd_create(CLOCK_MONOTONIC, 0);\n    if (fd == -1) {\n        fprintf(stderr, \"Call to timerfd_create failed.\\n\"); \n        perror(\"timerfd_create\");\n        fflush(stderr); \n        exit(EXIT_FAILURE);\n    }\n\n    /* Make the timer periodic */\n    its.it_value.tv_sec = (time_t)period;\n    its.it_value.tv_nsec = (period - (time_t)period) * 1000000000;\n    its.it_interval.tv_sec = its.it_value.tv_sec;\n    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n    status = timerfd_settime(fd, 0, &its, NULL);\n    CHECK_STATUS(status, 0, \"timer_settime\");\n    \n    return fd;\n}\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\nvoid mw_init_timerTaskSem(int idx)\n{\n    int status;\n    status = sem_init(&timerTaskSem[idx], 0, 0);\n    CHECK_STATUS(status, 0, \"sem_init:mw_init_timerTaskSem\");\n}\n\nint mw_CreateUnarmedTimer(double period, int idx)\n{\n    int fd;\n    int status;\n\n    /* Create the timer */\n    fd = timerfd_create(CLOCK_MONOTONIC, 0);\n    timer_fd[idx] = fd;\n    timer_period[idx] = period;\n    if (fd == -1) {\n        fprintf(stderr, \"Call to timerfd_create failed.\\n\"); \n        perror(\"timerfd_create\");\n        fflush(stderr); \n        exit(EXIT_FAILURE);\n    }     \n    /* Signal that the timer has been created. */\n    status = sem_post(&timerTaskSem[idx]); \n    CHECK_STATUS(status, 0, \"sem_post:mw_CreateUnarmedTimer\");     \n    #ifdef MW_RTOS_DEBUG\n        printf(\"Created unarmed timer # %d %d.\\n\", fd, idx);\n        fflush(stdout);\n    #endif    \n    return fd;\n}\n#endif\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\nvoid mw_ArmTimer(int idx)\n{\n    int status;\n    struct itimerspec its;\n    int fd = timer_fd[idx];\n    double period = timer_period[idx];\n    \n    its.it_interval.tv_sec = (time_t)period;\n    its.it_interval.tv_nsec = (period - (time_t)period) * 1000000000;\n    its.it_value.tv_sec = 0;\n    its.it_value.tv_nsec = 1.0;\n    #ifdef MW_RTOS_DEBUG\n        printf(\"About to arm timer # %d %d.\\n\", fd, idx);\n        fflush(stdout);\n    #endif\n    status = timerfd_settime(fd, 0, &its, NULL);\n    #ifdef MW_RTOS_DEBUG\n        printf(\"Armed timer # %d %d.\\n\", fd, idx);\n        fflush(stdout);\n    #endif\n    \n    CHECK_STATUS(status, 0, \"timer_settime\"); \n}\n#endif\n\nvoid mw_WaitForTimerEvent(int fd)\n{\n    unsigned long long missed;\n    int status;\n    \n    /* Wait for the next timer event. If we have missed any the\n       number is written to \"missed\" */\n    while ((status = read(fd, &missed, sizeof(missed)) == -1) && (errno == EINTR)) {\n        /* Restart if interrupted by a signal */\n        continue;\n    }\n    if (status == -1) {\n        perror(\"read(timerfd)\");\n    }\n}\n\nvoid mw_WaitForTimerEventCatchup(int fd)\n{\n    unsigned long long missed = 0;\n    int status = 0;\n    static unsigned int outstanding = 0;\n    \n    /* Wait for the next timer event. If we have missed any the\n     * number is written to \"missed\" */\n    if (outstanding == 0)\n    {\n        while ((status = read(fd, &missed, sizeof(missed)) == -1) && (errno == EINTR)) {\n            /* Restart if interrupted by a signal */\n            continue;\n        }\n        if (status == -1) {\n            perror(\"read(timerfd)\");\n        }\n        if (missed > 1) {\n            #ifdef MW_RTOS_DEBUG\n            printf(\"Missed %llu events for the timer # %d.\\n\", missed, fd);\n            fflush(stdout);\n            #endif\n            outstanding = outstanding + missed - 1;\n        }\n    }\n    else\n    {\n        #ifdef MW_RTOS_DEBUG\n        printf(\"Catching up with the missed events for timer # %d.\\n\", fd);\n        fflush(stdout);\n        #endif\n        outstanding--;\n    }\n}\n\n/* ---------------------------- */\n/* Internally visible functions */\n/* ---------------------------- */\n\n\n#ifdef MW_SOC_ENABLED\nvoid *baseTimerTask(void* arg)\n{\n    /* SOCB product installed and used */\n    int fd;\n    baseRateInfo_t info = *((baseRateInfo_t *)arg);\n\n    MW_DEBUG_LOG(\"baseTimerTask entered\\n\");\n    fd = mw_CreateArmedTimer(info.period);  \n    SOCB_RateCounterFcn();   \n    while(1) {\n        mw_WaitForTimerEvent(fd);\n        SOCB_RateCounterFcn();\n    }\n}\n#if (MW_NUM_APERIODIC_PROXY_TASKS > 0)\nvoid *proxyTaskEventSrcTask(void *unused)\n{\n    int fd;\n    int status;\n    double oldTime;\n    struct itimerspec its; \n    static int cnt = 0;\n    extern SOC_eventSourceDataType SOC_eventSourceData[];\n    SOC_eventSourceDataType *pOldEvent = NULL;\n    SOC_eventSourceDataType *pNewEvent = NULL;\n    pNewEvent = (SOC_eventSourceDataType*) &SOC_eventSourceData[cnt];\n    double period = pNewEvent->time + 1e-9; // cannot be zero\n    fprintf(stderr, \"First timer value %g\\n\", period); \n    fflush(stderr);\n    \n    MW_DEBUG_LOG(\"proxyTaskSrcTask entered\\n\");\n    fd = mw_CreateArmedTimer(period);  \n    while(1) {\n        MW_DEBUG_LOG(\"waiting for proxyTaskSrcTask timer event\\n\");\n        mw_WaitForTimerEvent(fd);\n        MW_DEBUG_LOG(\"got proxyTaskSrcTask timer event\\n\");\n        sem_post(&SOCB_ProxyTaskSem[(int) pNewEvent->semIdx]);\n        /* Update the timer period for the next event */\n        if (++cnt < SOC_MAXEVENTSRCCOUNTER) {\n            pOldEvent = (SOC_eventSourceDataType*) &SOC_eventSourceData[cnt-1];\n            pNewEvent = (SOC_eventSourceDataType*) &SOC_eventSourceData[cnt];\n            period = pNewEvent->time - pOldEvent->time;// what if zero??? \n            fprintf(stderr, \"Next timer value %g\\n\", period);\n            fflush(stderr);\n        } else {\n            period = 0.0;   \n        }\n        its.it_value.tv_sec = (time_t)period;\n        its.it_value.tv_nsec = (period - (time_t)period) * 1000000000;\n        its.it_interval.tv_sec = its.it_value.tv_sec;\n        its.it_interval.tv_nsec = its.it_value.tv_nsec;\n        status = timerfd_settime(fd, 0, &its, NULL);\n        CHECK_STATUS(status, 0, \"timer_settime\");   \n    }\n}\n#endif\n#else \nvoid *schedulerTask(void* arg)\n{\n    /* SOCB product not installed or not used */\n    int fd;\n    baseRateInfo_t info = *((baseRateInfo_t *)arg);\n\n    MW_DEBUG_LOG(\"schedulerTask entered\\n\");\n    fd = mw_CreateArmedTimer(info.period);\n    sem_post(&baserateTaskSem); \n    while(runModel) {\n        mw_WaitForTimerEvent(fd);\n        #ifdef DETECT_OVERRUNS        \n            testForRateOverrun(0);\n        #endif\n        sem_post(&baserateTaskSem);\n    }\n}\n\n#ifdef MW_SCHEDULE_TASK_WITH_ALSA_AUDIO\nvoid *schedulerTaskALSA(void* arg)\n{\n    /*Register the ALSA Audio capture block with base rate */\n    mw_alsa_registerCallback();\n}\n\nvoid triggerBaseRate(void){\n    /*Post the semaphore after period event from ALSA block*/\n    sem_post(&baserateTaskSem);\n}\n#endif\n#endif\n\n\n/* Should use this fcn, but currently are not using it */\n/* Why: it is safe ??? from interruption */\nvoid my_sem_wait(sem_t *sem)\n{\n    int status;\n    while (((status = sem_wait(sem)) == -1) && (errno == EINTR)) {\n        /* Restart if interrupted by a signal */\n        continue;\n    }\n    CHECK_STATUS(status, 0, \"my_sem_wait\");\n}\n\nstatic void setThreadPriority(const int priority, pthread_attr_t *attr, struct sched_param *sp)\n{\n#if MW_SP_SCHED_FIFO\n    int status;\n    \n    sp->sched_priority = priority;\n    status = pthread_attr_setschedparam(attr, sp);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedparam\");\n#endif\n}\n\n/* ---------------------------- */\n/* Externally visible functions */\n/* ---------------------------- */\n\nvoid mw_CreateTask(void * (*taskHandler)(void *), const char* taskName, int priority, int policy, int coreSelection, int coreNum)\n{\n    int status;\n    int inherit;\n    pthread_attr_t attr;\n    pthread_t thread;\n    struct sched_param param;\n    size_t stackSize;\n    pthread_attr_init(&attr);\n    cpu_set_t cpuset;\n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    char thisTaskName[MW_MAX_TASKNAME];\n#endif\n\n    /* Set thread inherit attribute */\n    inherit = PTHREAD_EXPLICIT_SCHED;\n    status = pthread_attr_setinheritsched(&attr, inherit);\n    CHECK_STATUS(status, 0, \"pthread_attr_setinheritsched\");\n\n    /* Set thread detach attribute */\n    status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    CHECK_STATUS(status, 0, \"pthread_attr_setdetachstate\");\n\n    /* Set thread stack size attribute */\n    stackSize = (512 > PTHREAD_STACK_MIN) ? 512:PTHREAD_STACK_MIN;\n    status = pthread_attr_setstacksize(&attr, stackSize);\n    CHECK_STATUS(status, 0, \"pthread_attr_setstacksize\");\n\n    /* Set thread schedule policy attribute */\n    policy = SCHED_FIFO;\n    status = pthread_attr_setschedpolicy(&attr, policy);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n\n    /* Set thread priority attribute */\n    param.sched_priority = priority;\n    status = pthread_attr_setschedparam(&attr, &param);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedparam\");\n    \n    /* Set the thread core affinity */\n    if (2 == coreSelection) \n    {\n        CPU_ZERO(&cpuset);\n        CPU_SET(coreNum, &cpuset);\n        status =  pthread_attr_setaffinity_np(&attr, sizeof(cpu_set_t), &cpuset);\n        CHECK_STATUS(status, 0, \"pthread_attr_setaffinity_np\");\n    }\n\n    /* Create the thread */\n    status = pthread_create(&thread, &attr, taskHandler, NULL);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    /* Set name of the thread */\n    snprintf(thisTaskName, MW_MAX_TASKNAME, \"%s\", taskName);\n    status = pthread_setname_np(thread, thisTaskName);\n    CHECK_STATUS(status, 0, \"pthread_setname_np at mw_CreateTask\");\n#endif\n    pthread_attr_destroy(&attr);\n}\n\nvoid myAddBlockForThisEvent(int sigNo)\n{\n    int status;\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    status = pthread_sigmask(SIG_BLOCK, &sigMask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_sigmask\");\n}\n\nvoid myAddHandlerForThisEvent(int sigNo, int sigToBlock[], int numSigToBlock, void (*sigHandler)(int))\n{\n    int idx;\n    int status;\n    struct sigaction sa;\n\n    sa.sa_handler = (__sighandler_t) sigHandler;\n    sigemptyset(&sa.sa_mask);\n    for (idx=0; idx<numSigToBlock; idx++) {\n            sigaddset(&sa.sa_mask, sigToBlock[idx]);\n    }\n    sa.sa_flags = SA_RESTART; /* Restart functions if interrupted by handler */\n    status = sigaction(sigNo, &sa, NULL);\n    CHECK_STATUS_NOT(status, -1, \"sigaction to register a signal handler\");\n}\n\nvoid myRestoreDefaultHandlerForThisEvent(int sigNo)\n{\n    int status;\n    struct sigaction sa;\n    sa.sa_handler = SIG_DFL;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART; /* Restart functions if interrupted by handler */\n    status = sigaction(sigNo, &sa, NULL);\n    CHECK_STATUS_NOT(status, -1, \"sigaction to restore default signal handler\");\n}\n\n/* ***********************************************************************/\n/* ***********************************************************************/\n/* ***********************************************************************/\n\nvoid myRTOSInit(double baseRatePeriod, int numSubrates)\n{\n    int i;\n    int status;\n    uid_t euid;\n    size_t stackSize;\n    unsigned long cpuMask = 0x1;\n    unsigned int len = sizeof(cpuMask);  \n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    char thisTaskName[MW_MAX_TASKNAME];\n#endif\n\n#if (defined(MW_TSKMGR_EVENT_DRIVEN_TASKS) && (MW_TSKMGR_EVENT_DRIVEN_TASKS > 0))\n    {\n        int idx;\n        for (idx=0;idx < MW_TSKMGR_EVENT_DRIVEN_TASKS;idx++)\n        {\n            mw_CreateTask(asyncTaskCodeGenInfo[idx].pAsyncTasks, \\\n                    (const char*) asyncTaskCodeGenInfo[idx].taskName,\\\n                    asyncTaskCodeGenInfo[idx].priority, \\\n                    asyncTaskCodeGenInfo[idx].policy, \\\n                    asyncTaskCodeGenInfo[idx].coreSelection, \\\n                    asyncTaskCodeGenInfo[idx].coreNum);\n#if defined(MW_SOC_ENABLED)\n    /* pause the main thread for 50us, so that main thread goes to waiting state and event driven tasks initialize properly. */\n    /* event driven tasks take ~30-40 us for the initialization.*/\n    /* for more information refer geck 2045382. */        \n\t\t\tusleep(50);\n#endif\n        }\n    }\n#endif\n    UNUSED(baseRatePeriod);\n    UNUSED(numSubrates);\n        \n    if (!MW_IS_CONCURRENT) {\n        /* All threads created by this process will run on a single CPU */\n        status = sched_setaffinity(0, len, (cpu_set_t *) &cpuMask);\n        CHECK_STATUS(status, 0, \"sched_setaffinity\");\n    }\n\n#if MW_SP_SCHED_FIFO && !defined (_POSIX_THREAD_PRIORITY_SCHEDULING)\n    fprintf(stderr, \"Priority scheduling is NOT supported by your system.\\n\");\n    fprintf(stderr, \"The generated code will not run correctly because your\\n\");\n    fprintf(stderr, \"model contains multiple rates and uses multi-tasking\\n\");\n    fprintf(stderr, \"code generation mode. You can only run the generated code\\n\");\n    fprintf(stderr, \"in single-tasking mode in your system. Open\\n\");\n    fprintf(stderr, \"Simulation -> Configuration Parameters -> Solver dialog\\n\");\n    fprintf(stderr, \"and set \\\"Tasking mode for periodic sample times\\\" parameter to SingleTasking.\\n\");\n    fprintf(stderr, \"Re-build the Simulink model with the new settings and try executing the generated code again.\\n\");\n    fflush(stderr);\n    exit(EXIT_FAILURE);\n#endif\n    \n#if MW_SP_SCHED_FIFO\n    /* Need root privileges for real-time scheduling */\n    euid = geteuid();\n    if (euid != 0) {\n        fprintf(stderr, \"You must have root privileges to run the generated code because\\n\");\n        fprintf(stderr, \"generated code requires SCHED_FIFO scheduling class to run correctly.\\n\");\n        fprintf(stderr, \"Try running the executable with the following command: sudo ./<executable name>\\n\");\n        fflush(stderr);\n        exit(EXIT_FAILURE);\n    }\n#endif\n\n    status = sem_init(&baserateTaskSem, 0, 0);\n    CHECK_STATUS(status, 0, \"sem_init:baserateTaskSemSem\");\n    status = sem_init(&stopSem, 0, 0);\n    CHECK_STATUS(status, 0, \"sem_init:stopSem\");\n    \n#if MW_SP_SCHED_FIFO\n    /* Set scheduling policy of the main thread to SCHED_FIFO */\n    sp.sched_priority = sched_get_priority_max(SCHED_FIFO);\n    status = sched_setscheduler(0, SCHED_FIFO, &sp);\n    CHECK_STATUS(status, 0, \"sched_setscheduler\");\n#endif\n\n    /* Create threads executing the Simulink model */\n    pthread_attr_init(&attr);\n    status = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n    CHECK_STATUS(status, 0, \"pthread_attr_setinheritsched\");\n#if MW_SP_SCHED_FIFO\n    status = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);\n#else\n    status = pthread_attr_setschedpolicy(&attr, SCHED_OTHER);\n#endif\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n    status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    CHECK_STATUS(status, 0, \"pthread_attr_setdetachstate\");\n\n    /* Set thread stack size if necessary */\n    status = pthread_attr_getstacksize(&attr, &stackSize);\n    CHECK_STATUS(status, 0, \"pthread_attr_getstacksize\");\n    if (stackSize < STACK_SIZE) {\n        /* Make sure that stackSize is a multiple of 8 */\n        stackSize = (STACK_SIZE + 7) & (~0x7);\n        pthread_attr_setstacksize(&attr, stackSize);\n        CHECK_STATUS(status, 0, \"pthread_attr_setstacksize\");\n    }\n\n    signal(SIGTERM, exitFcn);     /* kill */\n    signal(SIGHUP, exitFcn);      /* kill -HUP */\n    signal(SIGINT, exitFcn);      /* Interrupt from keyboard */\n    signal(SIGQUIT, exitFcn);     /* Quit from keyboard */\n\n#ifdef MW_STANDALONE_EXECUTION_PROFILER_ON\n    status = pthread_mutex_init(&profilingDataStoreMutex, NULL);    \n#endif\n    \n#ifdef MW_HAS_MULTIPLE_RATES\n    MW_DEBUG_LOG(\"**creating subrate task threads**\\n\");   \n    for (i = 0; i < MW_NUMBER_SUBRATES; i++) {\n        taskId[i] = i;\n        status = sem_init(&subrateTaskSem[i], 0, 0);\n        CHECK_STATUS(status, 0, \"sem_init\");\n        setThreadPriority(subratePriority[i], &attr, &sp);\n        status = pthread_create(&subRateThread[i], &attr, &subrateTask, (void *)&taskId[i]);\n        CHECK_STATUS(status, 0, \"pthread_create\");\n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n        /* Set name of sub-rate threads */\n        snprintf(thisTaskName, MW_MAX_TASKNAME, \"%s\", _mwTskMgrTimerDrivenTaskNames[i+1]);\n        MW_DEBUG_LOG(thisTaskName);   \n        status = pthread_setname_np(subRateThread[i], thisTaskName);\n        CHECK_STATUS(status, 0, \"pthread_setname_np at subRateThread\");\n#endif        \n#if !defined(MW_SOC_ENABLED) && defined(DETECT_OVERRUNS)\n        status = pthread_mutex_init(&rateTaskFcnRunningMutex[i+1], NULL);\n        CHECK_STATUS(status, 0, \"pthread_mutex_init\");\n#endif        \n#ifdef COREAFFINITYREQUIRED\n        if (coreAffinity[i] >= 0) {\n             cpu_set_t cpuset;\n             CPU_ZERO(&cpuset);\n             CPU_SET(coreAffinity[i], &cpuset);\n             status = pthread_setaffinity_np(subRateThread[i], sizeof(cpu_set_t), &cpuset);\n             CHECK_STATUS(status, 0, \"pthread_setaffinity_np\");\n         }\n#endif\n    }\n#endif\n\n    MW_DEBUG_LOG(\"**creating the base rate task thread**\\n\");    \n    setThreadPriority(MW_BASERATE_PRIORITY, &attr, &sp);  \n    status = pthread_create(&baseRateThread, &attr, &baseRateTask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n    \n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    /* Set name of the base-rate thread */\n    snprintf(thisTaskName, MW_MAX_TASKNAME, _mwTskMgrTimerDrivenTaskNames[0]);\n    status = pthread_setname_np(baseRateThread, thisTaskName);\n    CHECK_STATUS(status, 0, \"pthread_setname_np at baserateThread\");\n#endif\n    \n#if !defined(MW_SOC_ENABLED) && defined(DETECT_OVERRUNS)\n    status = pthread_mutex_init(&rateTaskFcnRunningMutex[0], NULL);\n    CHECK_STATUS(status, 0, \"pthread_mutex_init\");\n#endif\n\n#ifdef COREAFFINITYREQUIRED\n    if (coreAffinityBaseRate >= 0) {\n        cpu_set_t cpuset;\n        CPU_ZERO(&cpuset);\n        CPU_SET(coreAffinityBaseRate, &cpuset);\n        status = pthread_setaffinity_np(baseRateThread, sizeof(cpu_set_t), &cpuset);\n        CHECK_STATUS(status, 0, \"pthread_setaffinity_np\");\n    }   \n#endif\n\n#ifdef MW_SOC_ENABLED    \n#if (MW_NUM_APERIODIC_PROXY_TASKS > 0)    \n    MW_DEBUG_LOG(\"**creating the socb proxy task event src thread **\\n\");  \n    /* Set the priority just below the highest possible */    \n    setThreadPriority(sched_get_priority_max(SCHED_FIFO)-1, &attr, &sp);\n    status = pthread_create(&proxyTaskEventSrcThread, &attr, &proxyTaskEventSrcTask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n    status = pthread_setname_np(proxyTaskEventSrcThread, \"proxyTaskEventSrcTask\"); \n#endif    \n    MW_DEBUG_LOG(\"**creating the socb base rate timer handler thread**\\n\");  \n    /* Set the priority the highest possible */  \n    setThreadPriority(sched_get_priority_max(SCHED_FIFO), &attr, &sp);\n    info.period = MW_BASERATE_PERIOD;\n    status = pthread_create(&baseTimerThread, &attr, &baseTimerTask, (void *) &info);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n    status = pthread_setname_np(baseTimerThread, \"baseTimerTask\");\n#endif \n    \n    MW_DEBUG_LOG(\"**creating the scheduler thread**\\n\");  \n    #ifdef MW_SCHEDULE_TASK_WITH_ALSA_AUDIO\n        status = pthread_create(&schedulerThread, &attr, &schedulerTaskALSA, (void *) &info);\n    #else\n        /* Set the priority higher (higher number) than the base rate */    \n        setThreadPriority(MW_BASERATE_PRIORITY + 1, &attr, &sp);\n        info.period = MW_BASERATE_PERIOD;\n        status = pthread_create(&schedulerThread, &attr, &schedulerTask, (void *) &info);\n    #endif\n    CHECK_STATUS(status, 0, \"pthread_create\");\n       \n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    /* Set name of the scheduler thread */\n    snprintf(thisTaskName, MW_MAX_TASKNAME, \"scheduler\");\n    status = pthread_setname_np(schedulerThread, thisTaskName);\n    CHECK_STATUS(status, 0, \"pthread_setname_np at scheduler thread\");\n#endif\n\n#ifdef MW_HAS_APERIODIC_TASKS\n    MW_DEBUG_LOG(\"**creating asynchronously triggered task threads**\\n\"); \n    /* Set the priority higher (higher number) than the base rate */    \n    sp.sched_priority = MW_BASERATE_PRIORITY + 1;\n    for (i = 0; i < MW_NUMBER_APERIODIC_TASKS; i++) {\n        status = pthread_create(&asyncThread[i], &attr, (void *) pAsyncTasks[i], NULL);\n        CHECK_STATUS(status, 0, \"pthread_create\");\n    }\n#endif\n    \n#ifdef MW_NEEDS_BACKGROUND_TASK\n    MW_DEBUG_LOG(\"**creating the background thread**\\n\");\n    status = pthread_attr_setschedpolicy(&attr, SCHED_OTHER);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n    setThreadPriority(0, &attr, &sp);\n    status = pthread_create(&backgroundThread, &attr, &backgroundTask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    /* Set name of the background thread */\n    snprintf(thisTaskName, MW_MAX_TASKNAME, \"background\");\n    status = pthread_setname_np(backgroundThread, thisTaskName);\n    CHECK_STATUS(status, 0, \"pthread_setname_np at backgroundThread\");\n#endif \n#if MW_SP_SCHED_FIFO == 0\n    status = pthread_setschedparam(backgroundThread, SCHED_IDLE, &sp);\n    CHECK_STATUS(status, 0, \"pthread_setschedparam\");\n#ifdef MW_HAS_COMM_SERVICE\n    status = makeCSTaskIdle();\n    CHECK_STATUS(status, 0, \"pthread_setschedparam\");\n#endif \n#endif\n#endif\n\n    pthread_attr_destroy(&attr);\n    fflush(stdout);\n}\n"}]};